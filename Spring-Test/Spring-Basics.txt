This document contains some basics of Spring.

==> The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise 
    applications - on any kind of deployment platform.

--> A key element of Spring is infrastructural support at the application level:
    Spring focuses on the "plumbing" of enterprise applications so that teams can focus on application-level 
    business logic, without unnecessary ties to specific deployment environments.
	

==> Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
	It provides an opinionated view of the Spring platform and third-party libraries so developers 
	can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.

=====================================================================================================================
1. Spring Core
------------------

--> The org.springframework.beans and org.springframework.context packages are the basis for 
    Spring Framework’s IoC container

--> The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object. 
    ApplicationContext is a sub-interface of BeanFactory.

--> In short, the BeanFactory provides the configuration framework and basic functionality, 
    and the ApplicationContext adds more enterprise-specific functionality. 
	The ApplicationContext is a complete superset of the BeanFactory and is used exclusively in this 
	chapter in descriptions of Spring’s IoC container.

--> In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container 
	are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a 
	Spring IoC container. Otherwise, a bean is simply one of many objects in your application.

--> The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is 
	responsible for instantiating, configuring, and assembling the beans. 

--> The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration 
	metadata. The configuration metadata is represented in XML, Java annotations, or Java code. 

--> Several implementations of the ApplicationContext interface are supplied with Spring. 
	In stand-alone applications, it is common to create an instance of 
	ClassPathXmlApplicationContext or FileSystemXmlApplicationContext. 

--> While XML has been the traditional format for defining configuration metadata, 
	you can instruct the container to use Java annotations or code as the metadata format by providing 
	a small amount of XML configuration to declaratively enable support for these additional metadata formats.

--> the Spring IoC container consumes a form of configuration metadata. 
	This configuration metadata represents how you, as an application developer, 
	tell the Spring container to instantiate, configure, and assemble the objects in your application.

-->  	XML-based metadata is not the only allowed form of configuration metadata. 
	The Spring IoC container itself is totally decoupled from the format in which this configuration metadata 
	is actually written. These days, many developers choose Java-based configuration for their Spring applications.


Java-Based Container Configuration
----------------------------------

==> The central artifacts in Spring’s new Java-configuration support are: 
	@Configuration-annotated classes and @Bean-annotated methods.

--> The @Bean annotation is used to indicate that a method instantiates, configures, and 
	initializes a new object to be managed by the Spring IoC container.
 
-->  For those familiar with Spring’s <beans/> XML configuration, 
	the @Bean annotation plays the same role as the <bean/> element. 

--> You can use @Bean-annotated methods with any Spring @Component. 
	However, they are most often used with @Configuration beans.

--> Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. 
	Furthermore, @Configuration classes let inter-bean dependencies be defined by calling 
	other @Bean methods in the same class. The simplest possible @Configuration class reads as follows:

	@Configuration
	public class AppConfig {

  	  @Bean
  	  public MyService myService() {
        	return new MyServiceImpl();
    	  }
	}

--> The preceding AppConfig class is equivalent to the following Spring <beans/> XML:

	<beans>
   	     <bean id="myService" class="com.acme.services.MyServiceImpl"/>
	</beans>

==> Full @Configuration Vs Lite @Bean mode

	--> When @Bean methods are declared within classes that are not annotated with @Configuration, 
	they are referred to as being processed in a “lite” mode.

	--> Bean methods declared in a @Component or even in a plain old class are considered to be “lite”, 
	with a different primary purpose of the containing class and a @Bean method being a sort of bonus there. 
	
	--> Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies.
	Instead, they operate on their containing component’s internal state and, optionally, 
	on arguments that they may declare. Such a @Bean method should therefore not invoke other @Bean methods.

==> Instantiating the Spring Container by using AnnotationConfigApplicationContext

	--> AnnotationConfigApplicationContext is versatile ApplicationContext implementation capable of accepting not only
	@Configuration classes as input but also plain @Component classes and classes annotated with JSR-330 metadata.

	--> When @Configuration classes are provided as input, 
	the @Configuration class itself is registered as a bean definition and
	all declared @Bean methods within the class are also registered as bean definitions.
	
	--> When @Component and JSR-330 classes are provided, they are registered as bean definitions, 
	and it is assumed that DI metadata such as @Autowired or @Inject are used within those classes where necessary.

	--> In much the same way that Spring XML files are used as input when instantiating a 
	ClassPathXmlApplicationContext, you can use @Configuration classes as input when instantiating an 
	AnnotationConfigApplicationContext. 
	This allows for completely XML-free usage of the Spring container, as the following example shows:
	
	public static void main(String[] args) {
    		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
   		 MyService myService = ctx.getBean(MyService.class);
   		 myService.doStuff();
	}

	public static void main(String[] args) {
    		ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    		MyService myService = ctx.getBean(MyService.class);
    		myService.doStuff();
	}

	The preceding example assumes that MyServiceImpl, Dependency1, and Dependency2 
	use Spring dependency injection annotations such as @Autowired

	--> You can instantiate an AnnotationConfigApplicationContext by using a no-arg constructor 
	and then configure it by using the register() method. 
	This approach is particularly useful when programmatically building an AnnotationConfigApplicationContext. 
	The following example shows how to do so:

	public static void main(String[] args) {
   	 	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
   		ctx.register(AppConfig.class, OtherConfig.class);
    		ctx.register(AdditionalConfig.class);
   		ctx.refresh();
   		MyService myService = ctx.getBean(MyService.class);
    		myService.doStuff();
	}

	--> To enable component scanning, you can annotate your @Configuration class as follows:

	@Configuration
	@ComponentScan(basePackages = "com.acme")  // 	This annotation enables component scanning.
	public class AppConfig  {
  		  ...
	}

	--> In the preceding example, the com.acme package is scanned to look for any @Component-annotated classes, 
	and those classes are registered as Spring bean definitions within the container. 
	AnnotationConfigApplicationContext exposes the scan(String…​) method to allow for the same 
	component-scanning functionality, as the following example shows:

	public static void main(String[] args) {
    		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    		ctx.scan("com.acme");
    		ctx.refresh();
   		 MyService myService = ctx.getBean(MyService.class);
	}

	-->  Remember that @Configuration classes are meta-annotated with @Component, 
	so they are candidates for component-scanning. In the preceding example, assuming that AppConfig is 
	declared within the com.acme package (or any package underneath), it is picked up during the call to scan(). 
	Upon refresh(), all its @Bean methods are processed and registered as bean definitions within the container.

	--> A WebApplicationContext variant of AnnotationConfigApplicationContext is available with 
	AnnotationConfigWebApplicationContext. You can use this implementation when configuring the 
	Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, and so forth. 


==> Using the @Bean Annotation


	--> @Bean is a method-level annotation and a direct analog of the XML <bean/> element. 
	The annotation supports some of the attributes offered by <bean/>, such as: 
	* init-method * destroy-method * autowiring * name.

	--> You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.

	--> @Bean annotated method is used to register a bean definition within an ApplicationContext 
	of the type specified as the method’s return value. 
	By default, the bean name is the same as the method name. The following example shows a @Bean method declaration:

	@Configuration
	public class AppConfig {

   	 	@Bean
   		 public TransferServiceImpl transferService() {
       			 return new TransferServiceImpl();
    		}
	}

	-->The preceding configuration is exactly equivalent to the following Spring XML:

	<beans>
    		<bean id="transferService" class="com.acme.TransferServiceImpl"/>
	</beans>

	--> Both declarations make a bean named transferService available in the ApplicationContext, \
	bound to an object instance of type TransferServiceImpl, as the following text image shows:

		transferService -> com.acme.TransferServiceImpl

	--> You can also declare your @Bean method with an interface (or base class) return type, as the following example shows:
	
	@Configuration
	public class AppConfig {

   		 @Bean
    		public TransferService transferService() {
      		  return new TransferServiceImpl();
    		}
	}

	--> A @Bean-annotated method can have an arbitrary number of parameters that describe the dependencies 
	required to build that bean. For instance, if our TransferService requires an AccountRepository, 
	we can materialize that dependency with a method parameter, as the following example shows:


	@Configuration
	public class AppConfig {

   		@Bean
    		public TransferService transferService(AccountRepository accountRepository) {
       			return new TransferServiceImpl(accountRepository);
    		}
	}

	--> The resolution mechanism is pretty much identical to constructor-based dependency injection.

	--> Spring includes the @Scope annotation so that you can specify the scope of a bean.

	--> The default scope is singleton, but you can override this with the @Scope annotation, as the following example shows:

	@Configuration
	public class MyConfiguration {

    		@Bean
   		@Scope("prototype")
   		public Encryptor encryptor() {
       			 // ...
   		}
	}

	--> By default, configuration classes use a @Bean method’s name as the name of the resulting bean. 
	This functionality can be overridden, however, with the name attribute, as the following example shows:

	@Configuration
	public class AppConfig {

    		@Bean(name = "myThing")
    		public Thing thing() {
        		return new Thing();
    		}
	}

	--> it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing.
	 The name attribute of the @Bean annotation accepts a String array for this purpose. 
	The following example shows how to set a number of aliases for a bean:


	@Configuration
	public class AppConfig {

   		@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    		public DataSource dataSource() {
       			 // instantiate, configure and return DataSource bean...
    		}
	}

	--> Sometimes, it is helpful to provide a more detailed textual description of a bean. 
	This can be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.

	To add a description to a @Bean, you can use the @Description annotation, as the following example shows:

	@Configuration
	public class AppConfig {

   		 @Bean
   		 @Description("Provides a basic example of a bean")
   		 public Thing thing() {
       			 return new Thing();
    		 }
	}



==> Using the @Configuration annotation



	--> @Configuration is a class-level annotation indicating that an object is a source of bean definitions. 
	@Configuration classes declare beans through public @Bean annotated methods. 
	Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies.

	--> When beans have dependencies on one another, 
	expressing that dependency is as simple as having one bean method call another, as the following example shows:

	
	@Configuration
	public class AppConfig {

   		 @Bean
   		 public BeanOne beanOne() {
       			 return new BeanOne(beanTwo());
   		}

   		 @Bean
    		public BeanTwo beanTwo() {
        		return new BeanTwo();
    		}
	}

	--> In the preceding example, beanOne receives a reference to beanTwo through constructor injection.

	--> This method of declaring inter-bean dependencies works only when the @Bean method is 
	declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes. 

	-->  In Spring, instantiated beans have a singleton scope by default. 
	
	--> All @Configuration classes are subclassed at startup-time with CGLIB.
	As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes 
	have been repackaged under org.springframework.cglib and included directly within the spring-core JAR.
	


==> Composing Java-based configurations



	--> Spring’s Java-based configuration feature lets you compose annotations, which can reduce the complexity of 
	your configuration.

	--> Much as the <import/> element is used within Spring XML files to aid in modularizing configurations, 
	the @Import annotation allows for loading @Bean definitions from another configuration class, as the following example shows:

	@Configuration
	public class ConfigA {

   		 @Bean
   		 public A a() {
       			 return new A();
   		 }
	}

	@Configuration
	@Import(ConfigA.class)
	public class ConfigB {
	
   		 @Bean
   		 public B b() {
       			 return new B();
    		}
	}

	--> Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the context, only ConfigB needs to be supplied explicitly, as the following example shows:
	
	public static void main(String[] args) {
    		ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

   		 // now both beans A and B will be available...
   		 A a = ctx.getBean(A.class);
   		 B b = ctx.getBean(B.class);
	}

	--> This approach simplifies container instantiation, as only one class needs to be dealt with, rather than 
	requiring you to remember a potentially large number of @Configuration classes during construction.

	-->  As of Spring Framework 4.2, @Import also supports references to regular component classes, 
	analogous to the AnnotationConfigApplicationContext.register method. This is particularly useful if you want 
	to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your 
	components. 

	--> Injecting Dependencies on Imported @Bean Definitions
	
	-->  In most practical scenarios, beans have dependencies on one another across configuration classes. 
	When using XML, this is not an issue, because no compiler is involved, and you can declare ref="someBean" and 
	trust Spring to work it out during container initialization. 
	When using @Configuration classes, the Java compiler places constraints on the configuration model, 
	in that references to other beans must be valid Java syntax.

	--> a @Bean method can have an arbitrary number of parameters that describe the bean dependencies. 
	Consider the following more real-world scenario with several @Configuration classes, 
	each depending on beans declared in the others:

	@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}

	--> There is another way to achieve the same result.
	 Remember that @Configuration classes are ultimately only another bean in the container: 
	This means that they can take advantage of @Autowired and @Value injection and other features 
	the same as any other bean.

	--> @Configuration classes are processed quite early during the initialization of the context, 
	and forcing a dependency to be injected this way may lead to unexpected early initialization. 
	Whenever possible, resort to parameter-based injection, as in the preceding example.


	--> The following example shows how one bean can be autowired to another bean:

	@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}


	--> Constructor injection in @Configuration classes is only supported as of Spring Framework 4.3. 
	Note also that there is no need to specify @Autowired if the target bean defines only one constructor.

	--> If you wish to have direct navigation from within your IDE from one @Configuration class to another, 
	consider autowiring the configuration classes themselves. The following example shows how to do so:


	@Configuration
	public class ServiceConfig {

   		 @Autowired
    		private RepositoryConfig repositoryConfig;

    		@Bean
   		 public TransferService transferService() {
       			 // navigate 'through' the config class to the @Bean method!
        		return new TransferServiceImpl(repositoryConfig.accountRepository());
   	 	}
	}

	--> In the preceding situation, where AccountRepository is defined is completely explicit. 
	However, ServiceConfig is now tightly coupled to RepositoryConfig. That is the tradeoff. 
	This tight coupling can be somewhat mitigated by using interface-based or abstract class-based 
	@Configuration classes. (codes available in spring docs)


	-->  	If you want to influence the startup creation order of certain beans,
	 consider declaring some of them as @Lazy (for creation on first access instead of on startup) 
	or as @DependsOn certain other beans (making sure that specific other beans are created before the current bean, 
	beyond what the latter’s direct dependencies imply).

==> In cases where XML is convenient or necessary, you have a choice: 
either instantiate the container in an “XML-centric” way by using, for example, ClassPathXmlApplicationContext, 
or instantiate it in a “Java-centric” way by using AnnotationConfigApplicationContext and the @ImportResource annotation 
to import XML as needed.
	(See Spring docs for more details and code examples.)
=================================================================================================================================================================================================

2. Spring Data Access
---------------------

==> DAO Support
    -----------

	--> he Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies
	 (such as JDBC, Hibernate, or JPA) in a consistent way.
	
	--> This lets you switch between the aforementioned persistence technologies fairly easily,
	 and it also lets you code without worrying about catching exceptions that are specific to each technology.

	--> Spring provides a convenient translation from technology-specific exceptions, 
	such as SQLException to its own exception class hierarchy, which has DataAccessException as the root exception.

	--> In addition to JDBC exceptions, Spring can also wrap JPA- and Hibernate-specific exceptions, 
	converting them to a set of focused runtime exceptions. 

	--> The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation 
	is to use the @Repository annotation.

	-->  This annotation also lets the component scanning support find and configure your DAOs and repositories 
	without having to provide XML configuration entries for them. 
	The following example shows how to use the @Repository annotation:

	@Repository 
	public class SomeMovieFinder implements MovieFinder {
   		 // ...
	}

	--> Any DAO or repository implementation needs access to a persistence resource, depending on the persistence technology used. 
	For example, a JDBC-based repository needs access to a JDBC DataSource, 
	and a JPA-based repository needs access to an EntityManager. 
	The easiest way to accomplish this is to have this resource dependency injected by using one of 
	the @Autowired, @Inject, @Resource or @PersistenceContext annotations. 
	The following example works for a JPA repository:

	@Repository
	public class JpaMovieFinder implements MovieFinder {
	
   		 @PersistenceContext
    		private EntityManager entityManager;

    		// ...
	}
	
	--> If you use the classic Hibernate APIs, you can inject SessionFactory, as the following example shows:

	@Repository
	public class HibernateMovieFinder implements MovieFinder {

   		 private SessionFactory sessionFactory;

   		@Autowired
    		public void setSessionFactory(SessionFactory sessionFactory) {
      			  this.sessionFactory = sessionFactory;
    		}

   	 // ...
	}

	--> The last example we show here is for typical JDBC support. 
	You could have the DataSource injected into an initialization method or a constructor, 
	where you would create a JdbcTemplate and other data access support classes (such as SimpleJdbcCall and others)
	 by using this DataSource. The following example autowires a DataSource:

	@Repository
	public class JdbcMovieFinder implements MovieFinder {

   		 private JdbcTemplate jdbcTemplate;

   		 @Autowired
    		public void init(DataSource dataSource) {
        		this.jdbcTemplate = new JdbcTemplate(dataSource);
   		 }

   		 // ...
	}


==> Object Relational Mapping (ORM) Data Access
   ---------------------------------------------

	--> he Spring Framework supports integration with the Java Persistence API (JPA) and supports 
	native Hibernate for resource management, data access object (DAO) implementations, and transaction strategies. 
	
	--> The recommended integration style is to code DAOs against plain Hibernate or JPA APIs.

	-->  ORM in a Spring IoC container facilitates configuration and deployment. 
	Thus, most examples in this section show configuration inside a Spring container.

	--> Spring application contexts can handle the location and configuration of Hibernate SessionFactory instances, 
	JPA EntityManagerFactory instances, JDBC DataSource instances, and other related resources.
	
	--> Spring offers efficient, easy, and safe handling of persistence resources. 
	For example, related code that uses Hibernate generally needs to use the same Hibernate Session to ensure 
	efficiency and proper transaction handling. Spring makes it easy to create and bind a Session to 
	the current thread transparently, by exposing a current Session through the Hibernate SessionFactory. 
	Thus, Spring solves many chronic problems of typical Hibernate usage, for any local or JTA transaction environment.


==> Hibernate
   ----------

	--> you can define resources (such as a JDBC DataSource or a Hibernate SessionFactory) as beans 
	in the Spring container.
		Application objects that need to access resources receive references to such predefined instances 
	through bean references.

	--> The following excerpt from an XML application context definition shows how to set up a JDBC DataSource and a Hibernate SessionFactory on top of it:

	

<beans>

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
        <property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
        <property name="username" value="sa"/>
        <property name="password" value=""/>
    </bean>

    <bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <property name="dataSource" ref="myDataSource"/>
        <property name="mappingResources">
            <list>
                <value>product.hbm.xml</value>
            </list>
        </property>
        <property name="hibernateProperties">
            <value>
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            </value>
        </property>
    </bean>

</beans>

	--> Switching from a local Jakarta Commons DBCP BasicDataSource to a JNDI-located DataSource (usually managed by an application server) is only a matter of configuration, as the following example shows:

	

<beans>
    <jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
</beans>

	--> You can also access a JNDI-located SessionFactory, 
	using Spring’s JndiObjectFactoryBean / <jee:jndi-lookup> to retrieve and expose it. 
	However, that is typically not common outside of an EJB context.


	--> Spring also provides a LocalSessionFactoryBuilder variant, seamlessly integrating with 
	@Bean style configuration and programmatic setup (no FactoryBean involved).

	Both LocalSessionFactoryBean and LocalSessionFactoryBuilder support background bootstrapping, 
	with Hibernate initialization running in parallel to the application bootstrap thread on a given 
	bootstrap executor (such as a SimpleAsyncTaskExecutor). On LocalSessionFactoryBean, 
	this is available through the bootstrapExecutor property. 
	On the programmatic LocalSessionFactoryBuilder, there is an overloaded buildSessionFactory method that takes 
	a bootstrap executor argument.
	
	--> Hibernate has a feature called contextual sessions, wherein Hibernate itself manages one current Session
	 per transaction. This is roughly equivalent to Spring’s synchronization of one Hibernate Session per transaction. A corresponding DAO implementation resembles the following example, based on the plain Hibernate API:
	
	public class ProductDaoImpl implements ProductDao {

    		private SessionFactory sessionFactory;

   		 public void setSessionFactory(SessionFactory sessionFactory) {
       			 this.sessionFactory = sessionFactory;
   		 }

    		public Collection loadProductsByCategory(String category) {
       			 return this.sessionFactory.getCurrentSession()
                	.createQuery("from test.Product product where product.category=?")
               		 .setParameter(0, category)
                	.list();
    		}
	}


	--> You can annotate the service layer with @Transactional annotations and instruct the Spring container
	 to find these annotations and provide transactional semantics for these annotated methods. 
	The following example shows how to do so:

	public class ProductServiceImpl implements ProductService {

   		 private ProductDao productDao;

   		 public void setProductDao(ProductDao productDao) {
       		 	this.productDao = productDao;
    		}

   		 @Transactional
   		 public void increasePriceOfAllProductsInCategory(final String category) {
        		List productsToChange = this.productDao.loadProductsByCategory(category);
        		// ...
   	 	}

    		@Transactional(readOnly = true)
    		public List<Product> findAllProducts() {
       	 		return this.productDao.findAllProducts();
    		}	
	}

	--> In the container, you need to set up the PlatformTransactionManager implementation (as a bean) and 
	a <tx:annotation-driven/> entry, opting into @Transactional processing at runtime. 
	The following example shows how to do so:(see in docs)


	--> You can demarcate transactions in a higher level of the application, on top of lower-level data access services
	 that span any number of operations. Nor do restrictions exist on the implementation of the surrounding business 
	service. It needs only a Spring PlatformTransactionManager.

	--> public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            public void doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = this.productDao.loadProductsByCategory(category);
                // do the price increase...
            }
        });
    }
}


==> JPA
    ---

	--> The Spring JPA, available under the org.springframework.orm.jpa package, offers comprehensive support 
	for the Java Persistence API in a manner similar to the integration with Hibernate while being aware of the 
	underlying implementation in order to provide additional features.


	--> Three Options for JPA Setup in a Spring Environment
	
	--> The Spring JPA support offers three ways of setting up the JPA EntityManagerFactory that is used by 
	the application to obtain an entity manager.

		1. Using LocalEntityManagerFactoryBean --  use this option only in simple deployment environments 
				such as stand-alone applications and integration tests.

		2. Obtaining an EntityManagerFactory From JNDI --  use this option when deploying to a Java EE server. 

		3. Using LocalContainerEntityManagerFactoryBean -- use this option for full JPA capabilities in a 
			Spring-based application environment. This includes web containers such as Tomcat, 
			stand-alone applications, and integration tests with sophisticated persistence requirements.

	-->  	If you want to specifically configure a Hibernate setup, an immediate alternative is to go with 
		Hibernate 5.2 or 5.3 and set up a native Hibernate LocalSessionFactoryBean instead of a plain JPA 
		LocalContainerEntityManagerFactoryBean, letting it interact with JPA access code as well as native
		Hibernate access code. 	

	--> The LocalContainerEntityManagerFactoryBean gives full control over EntityManagerFactory configuration 
	and is appropriate for environments where fine-grained customization is required. 
	The LocalContainerEntityManagerFactoryBean creates a PersistenceUnitInfo instance based on the persistence.xml
	file, the supplied dataSourceLookup strategy, and the specified loadTimeWeaver.
	 It is, thus, possible to work with custom data sources outside of JNDI and to control the weaving process.
	
	--> Using the LocalContainerEntityManagerFactoryBean is the most powerful JPA setup option, allowing for 
	flexible local configuration within the application. It supports links to an existing JDBC DataSource, 
	supports both local and global transactions, and so on.

	--> This option may conflict with the built-in JPA capabilities of a Java EE server. 
	In a full Java EE environment, consider obtaining your EntityManagerFactory from JNDI.

	==> Implementing DAOs Based on JPA: EntityManagerFactory and EntityManager

	--> Although EntityManagerFactory instances are thread-safe, EntityManager instances are not.

	--> The injected JPA EntityManager behaves like an EntityManager fetched from an application server’s 
	JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional 
	EntityManager, if any. Otherwise, it falls back to a newly created EntityManager per operation, 
	in effect making its usage thread-safe. 

	--> It is possible to write code against the plain JPA without any Spring dependencies, 
	by using an injected EntityManagerFactory or EntityManager. 
	Spring can understand the @PersistenceUnit and @PersistenceContext annotations both at the field and 
	the method level if a PersistenceAnnotationBeanPostProcessor is enabled. 
	The following example shows a plain JPA DAO implementation that uses the @PersistenceUnit annotation:
	
	public class ProductDaoImpl implements ProductDao {

    		private EntityManagerFactory emf;

   		 @PersistenceUnit
   		 public void setEntityManagerFactory(EntityManagerFactory emf) {
      			  this.emf = emf;
   		 }

  		  public Collection loadProductsByCategory(String category) {
     			   try (EntityManager em = this.emf.createEntityManager()) {
         		  	 Query query = em.createQuery("from Product as p where p.category = ?1");
        		   	 query.setParameter(1, category);
           			 return query.getResultList();
        		}
   	 	}
	}

	--> The preceding DAO has no dependency on Spring and still fits nicely into a Spring application context. 

	--> The main problem with such a DAO is that it always creates a new EntityManager through the factory. 
	You can avoid this by requesting a transactional EntityManager (also called a “shared EntityManager” because 
	it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the 
	factory. The following example shows how to do so:

	public class ProductDaoImpl implements ProductDao {

   		 @PersistenceContext
   		 private EntityManager em;

   		 public Collection loadProductsByCategory(String category) {
       			 Query query = em.createQuery("from Product as p where p.category = :category");
        		query.setParameter("category", category);
        		return query.getResultList();
    		}
	}

	--> You can apply annotations that indicate dependency injections (such as @PersistenceUnit and 
	@PersistenceContext) on field or methods inside a class — hence the expressions 
	“method-level injection” and “field-level injection”. 
	Field-level annotations are concise and easier to use while method-level annotations allow for further processing 
	of the injected dependency. In both cases, the member visibility (public, protected, or private) does not matter.

	--> On the Java EE platform, class-level annotations are used for dependency declaration and not for
	resource injection.

==========================================================================================================================
Working with Spring Data Repositories
-------------------------------------

==> The goal of the Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required 
	to implement data access layers for various persistence stores.

Core Concepts
-------------

	--> The central interface in the Spring Data repository abstraction is Repository.
	It takes the domain class to manage as well as the ID type of the domain class as type arguments.
	This interface acts primarily as a marker interface to capture the types to work with and to help you to discover
	interfaces that extend this one. 

	--> The CrudRepository provides sophisticated CRUD functionality for the entity class that is being managed.


	public interface CrudRepository<T, ID> extends Repository<T, ID> {

 		 <S extends T> S save(S entity);      
 		 Optional<T> findById(ID primaryKey); 
 		 Iterable<T> findAll();               
  		 long count();                        
  		 void delete(T entity);               
  		 boolean existsById(ID primaryKey);   
  		// … more functionality omitted.
	}

	--> We also provide persistence technology-specific abstractions, such as JpaRepository or MongoRepository. 
	Those interfaces extend CrudRepository and expose the capabilities of the underlying persistence technology in 
	addition to the rather generic persistence technology-agnostic interfaces such as CrudRepository.

	--> On top of the CrudRepository, there is a PagingAndSortingRepository abstraction that adds additional methods
	 to ease paginated access to entities:

	public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
 		 Iterable<T> findAll(Sort sort);
 		 Page<T> findAll(Pageable pageable);
	}

	--> To access the second page of User by a page size of 20, you could do something like the following:

	PagingAndSortingRepository<User, Long> repository = // … get access to a bean
	Page<User> users = repository.findAll(PageRequest.of(1, 20));

Query Methods
-------------

	--> Standard CRUD functionality repositories usually have queries on the underlying datastore. 
	With Spring Data, declaring those queries becomes a four-step process:

	1. Declare an interface extending Repository or one of its subinterfaces and type it to the domain class and 
		ID type that it should handle.
	2. Declare query methods on the interface.
	3. Set up Spring to create proxy instances for those interfaces, either with JavaConfig or with XML configuration.
	4. Inject the repository instance and use it, as shown in the following example:

==========================================================================================================================================================================================================================================================================================================================================================
3. Spring Data JPA
------------------

==> Below are some methods present in JpaRepository<T, ID> interface.

	--> org.springframework.data.jpa.repository
	public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T>
	
	1. List<T> findAll()				//@Override
	2. List<T> findAll(Sort sort)			//@Override
	3. List<T> findAllById(Iterable<ID> ids)	//@Override
	4. <S extends T> List<S> saveAll(Iterable<S> entities)	//@Override
	5. void flush();
	6. <S extends T> S saveAndFlush(S entity);
	7. void deleteInBatch(Iterable<T> entities);
	8. void deleteAllInBatch();
	9. T getOne(ID id);
	10. <S extends T> List<S> findAll(Example<S> example);		//@Override
	11. <S extends T> List<S> findAll(Example<S> example, Sort sort); //@Override

	--> org.springframework.data.repository
	public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID>
	
	1. Iterable<T> findAll(Sort sort)
	2. Page<T> findAll(Pageable pageable)

	--> org.springframework.data.repository
	public interface CrudRepository<T, ID> extends Repository<T, ID>

	1. <S extends T> S save(S entity);
	2. <S extends T> Iterable<S> saveAll(Iterable<S> entities);
	3. Optional<T> findById(ID id);
	4. boolean existsById(ID id);
	5. Iterable<T> findAll();
	6. Iterable<T> findAllById(Iterable<ID> ids);
	7. long count();
	8. void deleteById(ID id);
	9. void delete(T entity);
	10. void deleteAll(Iterable<? extends T> entities);
	11. void deleteAll();

	--> org.springframework.stereotype.Indexed
	public interface Repository<T, ID>


JPA Repositories:
-----------------

-->  the basics of configuring Spring Data JPA through either:

   1.  “Spring Namespace” (XML configuration)
  
	1. The JPA module of Spring Data contains a custom namespace that allows defining repository beans. 
	It also contains certain features and element attributes that are special to JPA. Generally, the JPA repositories 
	can be set up by using the repositories element, as shown in the following example:

	 xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	http://www.springframework.org/schema/data/jpa
   	 https://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

  	<jpa:repositories base-package="com.acme.repositories" />

	--> Using the repositories element looks up Spring Data repositories.
	Beyond that, it activates persistence exception translation for all beans annotated with @Repository, 
	to let exceptions being thrown by the JPA persistence providers be converted into Spring’s DataAccessException hierarchy.

	--> Beyond the default attributes of the repositories element, the JPA namespace offers additional attributes 
	to let you gain more detailed control over the setup of the repositories:
	
		entity-manager-factory-ref
		transaction-manager-ref

	--> Spring Data JPA requires a PlatformTransactionManager bean named transactionManager to be present if 
	no explicit transaction-manager-ref is defined. 

   2.  “Annotation-based Configuration” (Java configuration)

	--> The Spring Data JPA repositories support can be activated not only through an XML namespace but 
	also by using an annotation through JavaConfig, as shown in the following example:
 	
	@Configuration
	@EnableJpaRepositories
	@EnableTransactionManagement
	class ApplicationConfig {

 		 @Bean
 		 public DataSource dataSource() {

   			 EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
   			 return builder.setType(EmbeddedDatabaseType.HSQL).build();
 		 }

 		 @Bean
 		 public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    			HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    			vendorAdapter.setGenerateDdl(true);

    			LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    			factory.setJpaVendorAdapter(vendorAdapter);
    			factory.setPackagesToScan("com.acme.domain");
    			factory.setDataSource(dataSource());
    			return factory;
  		}

  		@Bean
  		public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

   			JpaTransactionManager txManager = new JpaTransactionManager();
    			txManager.setEntityManagerFactory(entityManagerFactory);
    			return txManager;
 		 }
	}	


	-->  	You must create LocalContainerEntityManagerFactoryBean and not EntityManagerFactory directly, 
	since the former also participates in exception translation mechanisms in addition to creating EntityManagerFactory. 


	--> The preceding configuration class sets up an embedded HSQL database by using the 
	EmbeddedDatabaseBuilder API of spring-jdbc.
	Spring Data then sets up an EntityManagerFactory and uses Hibernate as the sample persistence provider. 
	The last infrastructure component declared here is the JpaTransactionManager. 
	Finally, the example activates Spring Data JPA repositories by using the @EnableJpaRepositories annotation, 
	which essentially carries the same attributes as the XML namespace. 
	If no base package is configured, it uses the one in which the configuration class resides.

	--> 

=============================================================================================================================
4. Web On Servlet Stack
-----------------------
	 Servlet-stack web applications built on the Servlet API and deployed to Servlet containers.
	 Spring Web MVC more commonly known as “Spring MVC” is the original web framework built on the Servlet API.

DispatcherServlet
-----------------

--> Spring MVC, as many other web frameworks, is designed around the front controller pattern where a central Servlet, 
the DispatcherServlet, provides a shared algorithm for request processing, while actual work is performed by configurable 
delegate components. 

--> The DispatcherServlet, as any Servlet, needs to be declared and mapped according to the Servlet specification 
by using Java configuration or in web.xml. 
	In turn, the DispatcherServlet uses Spring configuration to discover the delegate components it needs for 
request mapping, view resolution, exception handling, and more.


--> The following example of the Java configuration registers and initializes the DispatcherServlet,
 which is auto-detected by the Servlet container

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext servletCxt) {

        // Load Spring web application configuration
        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
        ac.register(AppConfig.class);
        ac.refresh();

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(ac);
        ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/app/*");
    }
}

-->  	In addition to using the ServletContext API directly, you can also extend 
AbstractAnnotationConfigDispatcherServletInitializer and override specific methods (see the example under Context Hierarchy).


-->  	Spring Boot follows a different initialization sequence. 
Rather than hooking into the lifecycle of the Servlet container, Spring Boot uses Spring configuration to 
bootstrap itself and the embedded Servlet container. Filter and Servlet declarations are detected in Spring configuration
 and registered with the Servlet container.

--> DispatcherServlet expects a WebApplicationContext (an extension of a plain ApplicationContext) for its own configuration. 

--> The root WebApplicationContext typically contains infrastructure beans, such as data repositories and business services
 that need to be shared across multiple Servlet instances.

--> The DispatcherServlet delegates to special beans to process requests and render the appropriate responses. 
By “special beans” we mean Spring-managed Object instances that implement framework contracts. 

--> The following table lists the Special Bean Types used by the DispatcherServlet:
	1. HandlerMapping
	2. HandlerAdapter
	3. HandlerExceptionResolver
	4. ViewResolver
	5. LocaleContextResolver
	6. ThemeResolver
	7. MultipartResolver
	8. FlashMapManager

--> Applications can declare the infrastructure beans listed in Special Bean Types that are required to process requests.

--> The DispatcherServlet checks the WebApplicationContext for each special bean. If there are no matching bean types, 
it falls back on the default types listed in DispatcherServlet.properties.


--> Browsers can submit form data only through HTTP GET or HTTP POST but non-browser clients can also use HTTP PUT, PATCH, and DELETE. 


Annotated Controllers
----------------------

==> Spring MVC provides an annotation-based programming model where @Controller and @RestController components use
 annotations to express request mappings, request input, exception handling, and more. 
Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces. 

==> 





======================================================================================================================

Spring MVC REST
===============

==> @RestController is a "composed annotation" that is itself meta-annotated with @Controller and @ResponseBody to 
indicate a controller whose every method inherits the type-level @ResponseBody annotation and, 
therefore, writes directly to the response body versus view resolution and rendering with an HTML template.


Request Mapping
---------------

--> You can use the @RequestMapping annotation to map requests to controllers methods.

-->  It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. 
You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping.

--> Following are HTTP method specific shortcut variants of @RequestMapping:
	1. @GetMapping
	2. @PostMapping
	3. @PutMapping
	4. @DeleteMapping
	5. @PatchMapping

--> The shortcuts are "Custom Annotations" that are provided because, arguably, most controller methods should be mapped
 to a specific HTTP method versus using @RequestMapping, which, by default, matches to all HTTP methods. 
At the same, a @RequestMapping is still needed at the class level to express shared mappings.

@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}

URI Patterns
------------

--> You can map requests by using glob patterns and wildcards:

	1. //	? --> Matches one character --> "/pages/t?st.html" --> matches "/pages/test.html" and "/pages/t3st.html"

	2. //	* --> Matches zero or more characters within a path segment
		  --> "/resources/*.png" matches "/resources/file.png"
		  --> "/projects/*/versions" matches "/projects/spring/versions" but does not match "/projects/spring/boot/versions"

	3. //	** --> Matches zero or more path segments until the end of the path
		   --> "/resources/**" matches "/resources/file.png" and "/resources/images/file.png"

	4. //	{name} --> Matches a path segment and captures it as a variable named "name"
			--> "/projects/{project}/versions" matches "/projects/spring/versions" and captures project=spring

	5. //	{name:[a-z]+} --> Matches the regexp "[a-z]+" as a path variable named "name"
			      --> "/projects/{project:[a-z]+}/versions" matches "/projects/spring/versions" but not "/projects/spring1/versions"


--> Captured URI variables can be accessed with @PathVariable, as the following example shows:

@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}

--> You can declare URI variables at the class and method levels, as the following example shows:
@RestController
@RequestMapping("/owners/{ownerId}")
public class OwnerController {

    @GetMapping("/pets/{petId}")
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}

Consumable Media Types
----------------------

--> You can narrow the request mapping based on the Content-Type of the request, as the following example shows:
 	Using a consumes attribute to narrow the mapping by the content type.

@PostMapping(path = "/pets", consumes = "application/json") 
public void addPet(@RequestBody Pet pet) {
    // ...
}

--> The consumes attribute also supports negation expressions — for example, !text/plain means any content type 
other than text/plain.

--> MediaType provides constants for commonly used media types, such as APPLICATION_JSON_VALUE and APPLICATION_XML_VALUE. 

Producible Media Types
----------------------

--> You can narrow the request mapping based on the Accept request header and the list of content types that a controller 
method produces, as the following example shows:
 	Using a produces attribute to narrow the mapping by the content type.

@GetMapping(path = "/pets/{petId}", produces = "application/json") 
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}


Parameters, headers
-------------------
--> You can narrow request mappings based on request parameter conditions. 
You can test for the presence of a request parameter (myParam), for the absence of one (!myParam), 
or for a specific value (myParam=myValue). The following example shows how to test for a specific value:

Testing whether myParam equals myValue.

@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") 
public void findPet(@PathVariable String petId) {
    // ...
}

--> You can also use the same with request header conditions, as the following example shows:
Testing whether myHeader equals myValue.

@GetMapping(path = "/pets", headers = "myHeader=myValue") 
public void findPet(@PathVariable String petId) {
    // ...
}

 --> You can match Content-Type and Accept with the headers condition, but it is better to use consumes and produces instead. 

HTTP HEAD, OPTIONS
------------------

--> @GetMapping (and @RequestMapping(method=HttpMethod.GET)) support HTTP HEAD transparently for request mapping. 

--> @GetMapping (and @RequestMapping(method=HttpMethod.GET)) are implicitly mapped to and support HTTP HEAD 

--> By default, HTTP OPTIONS is handled by setting the Allow response header to the list of HTTP methods listed in all @RequestMapping methods that have matching URL patterns.


Handler Methods
---------------

--> You can programmatically register handler methods, which you can use for dynamic registrations or for advanced cases,
 such as different instances of the same handler under different URLs. The following example registers a handler method:


@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) 
            throws NoSuchMethodException {  // 	Inject the target handler and the handler mapping for controllers.

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build();  // 	Prepare the request mapping meta data.

        Method method = UserHandler.class.getMethod("getUser", Long.class); //Get the handler method.

        mapping.registerMapping(info, handler, method); // 	Add the registration.
    }
}


--> @RequestMapping handler methods have a flexible signature and can choose from a range of supported controller 
method arguments and return values.

--> The next table describes the supported controller method return values. Reactive types are supported for all return values.


--> Some annotated controller method arguments that represent String-based request input 
(such as @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, and @CookieValue) can require type conversion 
if the argument is declared as something other than String.

--> Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values 
separated by comma (for example, /cars;color=red,green;year=2012). Multiple values can also be specified through repeated variable names (for example, color=red;color=green;color=blue).

--> You can use the @RequestParam annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.

--> You can use the @RequestHeader annotation to bind a request header to a method argument in a controller.

--> You can use the @CookieValue annotation to bind the value of an HTTP cookie to a method argument in a controller.

--> You can use the @ModelAttribute annotation on a method argument to access an attribute from the model or have it be instantiated if not present.

--> @SessionAttributes is used to store model attributes in the HTTP Servlet session between requests. 

--> you can use the @SessionAttribute annotation on a method parameter If you need access to pre-existing 
    session attributes that are managed globally (that is, outside the controller — for example, by a filter) and may or may not be present.

--> Similar to @SessionAttribute, you can use the @RequestAttribute annotations to access pre-existing request attributes 
created earlier (for example, by a Servlet Filter or HandlerInterceptor)

--> You can use the @RequestBody annotation to have the request body read and deserialized into an Object through an HttpMessageConverter.

--> HttpEntity is more or less identical to using @RequestBody but is based on a container object that exposes request headers and body.

--> You can use the @ResponseBody annotation on a method to have the return serialized to the response body through an HttpMessageConverter. 

@ResponseBody is also supported at the class level, in which case it is inherited by all controller methods. 
This is the effect of @RestController, which is nothing more than a meta-annotation marked with
 @Controller and @ResponseBody.

You can combine @ResponseBody methods with JSON serialization views.

--> ResponseEntity is like @ResponseBody but with status and headers. 

MultiPart
---------

--> After a MultipartResolver has been enabled, the content of POST requests with multipart/form-data is parsed and 
accessible as regular request parameters. The following example accesses one regular form field and one uploaded file:


Model
------

--> @ModelAttribute methods have flexible method signatures. 
They support many of the same arguments as @RequestMapping methods,
 except for @ModelAttribute itself or anything related to the request body.

UriComponents
--------------

--> UriComponentsBuilder helps to build URI’s from URI templates with variables, as the following example shows:

UriComponents uriComponents = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")  // Static factory method with a URI template.
        .queryParam("q", "{q}")  //Add or replace URI components.
        .encode()  	//Request to have the URI template and URI variables encoded.
        .build();  	Build a UriComponents.

URI uri = uriComponents.expand("Westin", "123").toUri();  // 	Expand variables and obtain the URI.


--> UriComponentsBuilder implements UriBuilder. You can create a UriBuilder, in turn, with a UriBuilderFactory. 

--> You can configure RestTemplate and WebClient with a UriBuilderFactory to customize the preparation of URIs. 


Links To Controller
------------------

--> Spring MVC provides a mechanism to prepare links to controller methods. For example, the following MVC controller allows for link creation:


@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

    @GetMapping("/bookings/{booking}")
    public ModelAndView getBooking(@PathVariable Long booking) {
        // ...
    }
}

You can prepare a link by referring to the method by name, as the following example shows:


UriComponents uriComponents = MvcUriComponentsBuilder
    .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();

Links in Views
--------------

--> In views such as Thymeleaf, FreeMarker, or JSP, you can build links to annotated controllers by referring to the 
implicitly or explicitly assigned name for each request mapping.


CORS (Cross Origin Resource Sharing)
=====================================

--> Spring MVC lets you handle CORS (Cross-Origin Resource Sharing). 


--> For security reasons, browsers prohibit AJAX calls to resources outside the current origin. 
For example, you could have your bank account in one tab and evil.com in another. 
Scripts from evil.com should not be able to make AJAX requests to your bank API with your credentials — for example withdrawing money from your account!

--> Cross-Origin Resource Sharing (CORS) is a W3C specification implemented by most browsers that lets you specify 
what kind of cross-domain requests are authorized, rather than using less secure and less powerful workarounds based on 
IFRAME or JSONP.

--> The CORS specification distinguishes between preflight, simple, and actual requests

--> Spring MVC HandlerMapping implementations provide built-in support for CORS. 

--> The @CrossOrigin annotation enables cross-origin requests on annotated controller methods, as the following example shows:

--> @RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    public Account retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public void remove(@PathVariable Long id) {
        // ...
    }
}

HTTP Caching
------------

--> HTTP caching can significantly improve the performance of a web application. HTTP caching revolves around the 
Cache-Control response header and, subsequently, conditional request headers (such as Last-Modified and ETag).



View Technologies
=================

--> The use of view technologies in Spring MVC is pluggable, 
whether you decide to use Thymeleaf, Groovy Markup Templates, JSPs, or other technologies, 
is primarily a matter of a configuration change. 

--> Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML templates that can be previewed 
in a browser by double-clicking, which is very helpful for independent work on UI templates (for example, by a designer) 
without the need for a running server.

--> Apache FreeMarker is a template engine for generating any kind of text output from HTML to email and others.

--> he Spring Framework has a built-in integration for using Spring MVC with any templating library that can run on top of the JSR-223 Java scripting engine. 

--> The Spring Framework has a built-in integration for using Spring MVC with JSP and JSTL.
	When developing with JSPs, you can declare a InternalResourceViewResolver or a ResourceBundleViewResolver bean.

--> Spring offers ways to return output other than HTML, including PDF and Excel spreadsheets.

Jackson JSON
-------------

--> Spring offers support for the Jackson JSON library.

--> Spring MVC provides built-in support for Jackson’s Serialization Views, which allow rendering only a subset of all 
fields in an Object. To use it with @ResponseBody or ResponseEntity controller methods,
 you can use Jackson’s @JsonView annotation to activate a serialization view class.

The MappingJackson2JsonView uses the Jackson library’s ObjectMapper to render the response content as JSON.


REST Client
===========

==> The Spring Framework provides two choices for making calls to REST endpoints:
	1. RestTemplate: The original Spring REST client with a synchronous, template method API.
	2. WebClient: a non-blocking, reactive alternative that supports both synchronous and asynchronous as well as streaming scenarios.

--> The RestTemplate provides a higher level API over HTTP client libraries. 
It makes it easy to invoke REST endpoints in a single line. It exposes the following groups of overloaded methods:


=========================================================================================================================

==> We want to use JSP as the view.
 Default embedded servlet container for Spring Boot Starter Web is tomcat.
 To enable support for JSP’s, we would need to add a dependency on tomcat-embed-jasper.

==============================================================================================================


